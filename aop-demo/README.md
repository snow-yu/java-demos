# aop-demo 

## 静态代理
> 静态代理模式是一种非常简单的代理模式，它是通过在代理类中直接调用目标对象的方法来实现的。

## 动态代理
> 动态代理模式是通过在程序运行期间动态生成一个代理对象，并由代理对象来调用目标对象的方法，这种方式的代理对象是程序运行期间产生的，而不是程序编译期间产生的。
> 动态代理的方式有两种：JDK动态代理和CGLIB动态代理。

### JDK动态代理
> 动态代理模式是通过在程序运行期间动态生成一个代理对象，并由代理对象来调用目标对象的方法，这种方式的代理对象是程序运行期间产生的，而不是程序编译期间产生的。

- JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法时，会先调用实现了 InvokeHandler 接口的 invoke() 方法，来实现业务增强
- 使用java放射包中的类和接口实现动态代理的功能， 反射包java.lang.reflect包中的Method类，可以获取到目标对象的方法，然后通过反射机制来调用目标对象的方法。
- 动态代理的实现类必须实现InvocationHandler接口，该接口定义了一个invoke方法，该方法接收一个方法调用的目标对象和方法调用的参数，并返回一个方法调用的结果。
- **动态代理的实现类必须实现一个接口**，该接口定义了一个方法，该方法接收一个方法调用的目标对象和方法调用的参数，并返回一个方法调用的结果。

### CGLIB动态代理
> CGLIB（Code Generation Library）是一个强大的，高性能，高质量的代码生 成包。它可以在运行期扩展java类与实现java接口。效率高于jdk代理

- Cglib 动态代理是利用 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理
- cglib的原理是继承，通过继承目标类，创建它的子类，在子类中重写父类中同名的方法，实现功能的修改。
- 由于cglib是继承、重写方法，所以要求目标类不能final，方法也不能是final。


## spring AOP
> Spring AOP是Spring框架提供的面向切面编程（AOP）的实现，它是基于动态代理实现的。

### spring aop
- 如果代理对象是接口，spring会使用JDK动态代理。
- 如果代理对象不是接口，spring会使用CGLIB动态代理。
- 优先使用JDK动态代理

### spring boot aop
- aop实现方式 2.0版本之前和spring一致
- 2.0版本之后，spring boot默认使用cglib动态代理，如果需要使用jdk动态代理，需要在配置文件中开启

 [参考链接](https://blog.csdn.net/weixin_38192427/article/details/121621872)
